- ```java
  ch.pipeline().addLast(HttpRequestHandler.INSTANCE);
  ch.pipeline().addLast(RegisterRequestHandler.INSTANCE);
  ch.pipeline().addLast(MessageRequestHandler.INSTANCE);
  ch.pipeline().addLast(CreateGroupRequestHandler.INSTANCE);
  ch.pipeline().addLast(GroupMessageRequestHandler.INSTANCE);
  ch.pipeline().addLast(HeartBeatRequestHandler.INSTANCE);
  ch.pipeline().addLast(ExceptionHandler.INSTANCE);
  ```
  - ```HttpRequestHandler```
  关于使用那个handler，通过前端传回控制字符控制，在第一个处理器(HttpHandler)中获取并添加到传输的包中
  - ```RegisterRequestHandler```
  从chanel中获取用户信息并注册到本地用户池？？？前置处理

- Websocket前后端传输的协议解析
  ```type```:
  ```prama```

- handler责任链模式 **设计模式**
  handler传入的参数类型必须与继承的父类传入的泛型一致，否则不会被执行；可以借此来选择handler


- 关于netty处理器继承的```SimpleChannelInboundHandler<T>``` 关于其传入的泛型

- json字符串与json对象的转换（前端）
  https://www.cnblogs.com/chengxs/p/8289890.html
  https://www.cnblogs.com/chengxs/p/8656723.html
- json字符串与json对象的转换（后端）
  见Mysocket类

- @Sharable不是线程安全的，多个channel共享一个handler实例

- TextWebSocketFrame 分多帧传输，在责任链第一条链分流 **这里运用了什么设计模式？**

- 前后端交互的方式
  - ```js
  socket.send(JSON.stringify(data));
  ```
  将json对象转变为json字符串以传输 后端将json字符串转变为json对象，再转变为bean
  ```
  //                将json对象转换为实体类
                User user =  JSON.parseObject(parmas.toJSONString(), User.class);
                registerRequestPacket.setUser(user);
  ```
- 如果直接用ajax/axios传后端用@responsebody接收自动转换
  > 和上一中方式的联系？是不是一样的？hander中的content-type参数

- 前后端鉴权和token暂未添加

- 消息队列的问题，传岑问题暂未解决

- 跨域问题
  - 后端使用@CrossOrigin注解
  - 前端使用注意添加http/https

- 使用element-UI
  - vue文件中可以使用全局引用的方式(毕竟是在vue的入口文件中引用的...)
  - js文件中需要额外import
  - main.js为vue架构的入口文件，app.vue为跟组件，在界面开始运行时挂载在index.html上

- 清楚前端的默认样式:在入口文件中引入类似于reset.css的样式清楚文件

- 数据改错 resultMap的column要和数据库的字段名对应上

- 通信服务器端和客户端使用json编码传输，前端传输时先转成json字符串，后端收到后转成jsonObject，再转为对应的实体类。后端先用用jsonObject封装，再转成字符，最后```byteBuf.writeBytes```封装，传回channel
> 要是不用json字符串做中转怎么办

> TextWebSocketFrame是什么，
> 和普通的string有什么区别，
> 和json之间如何转换，
> 可否将如websockethandler中的编码解码操作抽离